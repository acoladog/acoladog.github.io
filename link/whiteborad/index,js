const canvas = document.getElementById("whiteboard");
const sidebar = document.getElementById("sidebar");
const ctx = canvas.getContext("2d");
const brushBtn = document.getElementById("brush-btn");
const brushSettings = document.getElementById("brush-settings");
const brushColorInput = document.getElementById("brush-color");
const brushSizeInput = document.getElementById("brush-size");

let drawing = false;
let brushActive = false;
let brushColor = "#000000";
let brushSize = 5;

// 設置canvas尺寸和DPI適配
function setupCanvas() {
    const container = canvas.parentElement;
    const containerWidth = container.clientWidth;
    const containerHeight = Math.max(window.innerHeight * 1.5, 800); // 最小800px高度
    
    // 設置canvas的實際尺寸
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    // 設置canvas的顯示尺寸（CSS）
    canvas.style.width = containerWidth + 'px';
    canvas.style.height = containerHeight + 'px';
    
    // 設置繪圖上下文的初始狀態
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
}

// 初始化canvas
setupCanvas();

// 窗口大小改變時重新設置canvas
window.addEventListener('resize', setupCanvas);

// 獲取準確的鼠標坐標（考慮滾動和邊界）
function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
    x: (e.clientX - rect.left) * (canvas.width / rect.width),
    y: (e.clientY - rect.top) * (canvas.height / rect.height)
    };
}

// 側欄切換邏輯
document.body.addEventListener("click", function(e) {
    if (e.target !== canvas && !sidebar.contains(e.target) && !brushSettings.contains(e.target)) {
        const clickLeft = e.clientX < window.innerWidth / 2;
        const sidebarOnLeft = sidebar.style.left !== "auto";

        if ((clickLeft && sidebarOnLeft) || (!clickLeft && !sidebarOnLeft)) {
            sidebar.classList.toggle("hidden");
        } else {
            if (clickLeft) {
                sidebar.style.left = "4%";
                sidebar.style.right = "auto";
                brushSettings.style.left = "8%";
                brushSettings.style.right = "auto";
            } else {
                sidebar.style.right = "4%";
                sidebar.style.left = "auto";
                brushSettings.style.right = "8%";
                brushSettings.style.left = "auto";
            }
            sidebar.classList.remove("hidden");
        }
    }
});

// 筆刷按鈕邏輯
brushBtn.addEventListener("click", () => {
    if (!brushActive) {
        brushActive = true;
        brushSettings.classList.add("hidden");
        brushBtn.style.background = "#ffd1bf";
        canvas.style.cursor = "crosshair";
    } else {
        brushSettings.classList.toggle("hidden");
    }
});

// 更新筆刷設置
brushColorInput.addEventListener("input", (e) => brushColor = e.target.value);
brushSizeInput.addEventListener("input", (e) => brushSize = parseInt(e.target.value));

// 鼠標繪圖事件
canvas.addEventListener("mousedown", (e) => {
    if (!brushActive) return;
    
    drawing = true;
    const pos = getMousePos(e);
    
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
});

canvas.addEventListener("mousemove", (e) => {
    if (!drawing || !brushActive) return;
    
    const pos = getMousePos(e);
    
    ctx.lineTo(pos.x, pos.y);
    ctx.strokeStyle = brushColor;
    ctx.lineWidth = brushSize;
    ctx.stroke();
});

canvas.addEventListener("mouseup", () => {
    if (drawing) {
        drawing = false;
        ctx.closePath();
    }
});

canvas.addEventListener("mouseleave", () => {
    if (drawing) {
        drawing = false;
        ctx.closePath();
    }
});

// 觸控設備支持
canvas.addEventListener("touchstart", (e) => {
    if (!brushActive) return;
    
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousedown", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener("touchmove", (e) => {
    if (!drawing || !brushActive) return;
    
    e.preventDefault();
    const touch = e.touches[0];
    const mouseEvent = new MouseEvent("mousemove", {
        clientX: touch.clientX,
        clientY: touch.clientY
    });
    canvas.dispatchEvent(mouseEvent);
});

canvas.addEventListener("touchend", (e) => {
    e.preventDefault();
    const mouseEvent = new MouseEvent("mouseup", {});
    canvas.dispatchEvent(mouseEvent);
});