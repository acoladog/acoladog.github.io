<!DOCTYPE html>
<html>
<head>
	<style>
	     body {
	       background-color: antiquewhite;
	       margin: 0;
	       padding: 0;
	       overflow-x: auto;
	       overflow-y: auto;
         user-select: none !important;
	     }
	     body::-webkit-scrollbar {
	       display: none;
	     }

	     /* 白板容器 */
	     .whiteboard-container {
	       position: relative;
	       width: 94%;
	       margin: auto;
	       padding: 30px 0;
	     }

	     #whiteboard {
	       background-color: white;
	       display: block;
	       width: 100%;
	       cursor: crosshair;
	       border: 1px solid #ccc;
	       box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
	       touch-action: none;
	     }

	     /* 側欄 */
        #sidebar {
          position: fixed;
          top: 50px;
          left: 4%;
          width: 60px;
          background: rgba(255, 209, 191, 0.8);
          color: white;
          display: flex;
          flex-direction: column;
          gap: 10px;
          padding: 10px;
          border-radius: 10px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
          z-index: 1000;
        }

	     #sidebar button {
	       background: white;
	       border: none;
	       padding: 8px;
	       border-radius: 6px;
	       cursor: pointer;
	       transition: background 0.2s;
	     }

	     #sidebar button:hover { background: lightgray; }
	     #sidebar button.active { background: #ffd1bf; }
       .hidden{ display: none !important; }

       /* 筆刷設置面板 */
       #brush-settings {
        position: fixed;
        top: 20px;
        left: 12%;
        background: rgb(255 201 201 / 95%);
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1001;
        min-width: 280px;
        border: 1px solid #ccc;
      }

      #brush-settings label { display: block; margin-bottom: 15px; font-size: 14px; color: #333; font-weight: 500; }
      #brush-settings input[type="color"] { width: 50px; height: 30px; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px; }
      .size-control { display: flex; align-items: center; gap: 10px; margin-top: 5px; }
      #brush-settings input[type="range"] { flex: 1; cursor: pointer; }
      .size-display { font-weight: bold; color: #666; min-width: 40px; }
      .size-preview { width: 50px; height: 50px; display: flex; align-items: center; justify-content: center; border: 1px solid #ddd; border-radius: 4px; background: white; }
      .size-circle { background-color: #333; border-radius: 50%; transition: all 0.2s ease; }
      .tool-section { border: 1px solid #e0e0e0; border-radius: 6px; padding: 12px; margin-bottom: 10px; background: #ffb0b0; }
      .tool-section:last-child { margin-bottom: 0; }
      .tool-section h3 { margin: 0 0 10px 0; font-size: 14px; color: #555; font-weight: 600; }

      /* 頁面控制 */
      #page-controls {
        position: fixed; top: 88%; right: 2%; background: rgba(255, 255, 255, 0.95);
        padding: 10px 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 1001; display: flex; align-items: center; gap: 10px; border: 1px solid #ccc;
      }
      #page-controls button { background: #f0f0f0; border: 1px solid #ccc; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 14px; }
      #page-controls button:hover { background: #e0e0e0; }
      #page-controls button:disabled { background: #f8f8f8; color: #ccc; cursor: not-allowed; }
      #page-info { font-size: 14px; color: #333; font-weight: 500; min-width: 80px; text-align: center; }

      /* 橡皮擦游標 */
      #eraser-cursor {
        position: fixed; border: 2px solid #666; border-radius: 50%;
        background-color: rgba(255, 255, 255, 0.3); pointer-events: none;
        z-index: 1002; display: none; transform: translate(-50%, -50%);
      }

      /* 提示框 */
      #toast-msg {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.7); color: white; padding: 10px 20px;
        border-radius: 20px; font-size: 14px; pointer-events: none;
        opacity: 0; transition: opacity 0.5s; z-index: 2000;
      }
	</style>
	<title>Canvas白板 - 四角縮放版</title>
</head>
<body>
  <div id="toast-msg">提示：按 Ctrl+V 貼上圖片 | 拖曳四角縮放</div>

  <div id="brush-settings" class="hidden">
    <div id="brush-section" class="tool-section">
      <h3>筆刷設定</h3>
      <p style="display: flex;">顏色: <label><input type="color" id="brush-color" value="#000000"></label></p>
      <label>
        筆刷粗細: <span class="size-display" id="brush-size-display">2</span>
        <div class="size-control">
          <input type="range" id="brush-size" min="1" max="50" value="2">
          <div class="size-preview"><div class="size-circle" id="brush-size-circle"></div></div>
        </div>
      </label>
    </div>
    <div id="eraser-section" class="tool-section">
      <h3>橡皮擦設定</h3>
      <label>
        橡皮擦粗細: <span class="size-display" id="eraser-size-display">50px</span>
        <div class="size-control">
          <input type="range" id="eraser-size" min="5" max="200" value="50">
          <div class="size-preview"><div class="size-circle" id="eraser-size-circle"></div></div>
        </div>
      </label>
    </div>
  </div>

  <div id="eraser-cursor"></div>

  <div id="page-controls">
    <button id="prev-page">◀</button>
    <span id="page-info">第 1 頁</span>
    <button id="next-page">▶</button>
  </div>

	<div class="whiteboard-container">
		<canvas id="whiteboard"></canvas>
		<div id="sidebar" class="hidden">
			<button id="brush-btn" title="筆刷">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 17.25V21H6.75L17.81 9.94L14.06 6.19L3 17.25ZM20.71 7.04C21.1 6.65 21.1 6.02 20.71 5.63L18.37 3.29C17.98 2.9 17.35 2.9 16.96 3.29L15.13 5.12L18.88 8.87L20.71 7.04Z" fill="currentColor"/></svg>
      </button>
      <button id="eraser-btn" title="橡皮擦">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 15L15 5L21 11L11 21H5V15Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M13 7L19 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8 12V18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 18H8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
      </button>
      <button id="clear-btn" title="清除當前頁面">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6 19C6 20.1 6.9 21 8 21H16C17.1 21 18 20.1 18 19V7H6V19ZM19 4H15.5L14.5 3H9.5L8.5 4H5V6H19V4Z" fill="currentColor"/></svg>
      </button>
		</div>
	</div>
  
  <script>
    // --- 核心設定 ---
    const canvas = document.getElementById("whiteboard");
    const bgCanvas = document.createElement("canvas"); 
    const ctx = canvas.getContext("2d");
    const bgCtx = bgCanvas.getContext("2d");
    
    // DOM 元素
    const sidebar = document.getElementById("sidebar");
    const brushBtn = document.getElementById("brush-btn");
    const eraserBtn = document.getElementById("eraser-btn");
    const clearBtn = document.getElementById("clear-btn");
    const brushSettings = document.getElementById("brush-settings");
    const brushSection = document.getElementById("brush-section");
    const eraserSection = document.getElementById("eraser-section");
    const brushColorInput = document.getElementById("brush-color");
    const brushSizeInput = document.getElementById("brush-size");
    const eraserSizeInput = document.getElementById("eraser-size");
    const brushSizeDisplay = document.getElementById("brush-size-display");
    const eraserSizeDisplay = document.getElementById("eraser-size-display");
    const brushSizeCircle = document.getElementById("brush-size-circle");
    const eraserSizeCircle = document.getElementById("eraser-size-circle");
    const pageControls = document.getElementById("page-controls");
    const prevPageBtn = document.getElementById("prev-page");
    const nextPageBtn = document.getElementById("next-page");
    const pageInfo = document.getElementById("page-info");
    const eraserCursor = document.getElementById("eraser-cursor");
    const toastMsg = document.getElementById("toast-msg");

    // --- 狀態變數 ---
    let drawing = false;
    let currentTool = "none"; 
    let originalTool = "brush"; 
    let brushColor = "#000000";
    let brushSize = 2;
    let eraserSize = 50; 
    let currentPage = 1;
    let totalPages = 1;
    let pageData = {}; 
    let lastPoint = null; 
    let isPalmMode = false; 
    let palmModeTimeout = null; 
    let palmEraserSize = 100; 

    // --- 圖片變形相關變數 ---
    let images = [];
    let selectedImage = null;
    let isDraggingImg = false;
    let isResizingImg = false;
    let isRotatingImg = false;
    let dragStartX, dragStartY;
    let resizeDir = ""; // "nw", "ne", "sw", "se"
    // 紀錄變形前的狀態，用於計算
    let initialImgState = { x:0, y:0, w:0, h:0, angle:0 };

    class WhiteboardImage {
        constructor(img, x, y) {
            this.img = img;
            this.x = x;
            this.y = y;
            const maxSize = 400;
            if (img.width > maxSize) {
                this.width = maxSize;
                this.height = (img.height / img.width) * maxSize;
            } else {
                this.width = img.width;
                this.height = img.height;
            }
            this.angle = 0;
        }

        draw(context) {
            context.save();
            context.translate(this.x + this.width / 2, this.y + this.height / 2);
            context.rotate(this.angle);
            context.drawImage(this.img, -this.width / 2, -this.height / 2, this.width, this.height);
            
            if (selectedImage === this) {
                context.strokeStyle = "#00a8ff";
                context.lineWidth = 2;
                context.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                
                context.fillStyle = "white";
                context.strokeStyle = "#00a8ff";
                
                // 畫四個角的控制點
                const handleSize = 10;
                // NW (左上)
                context.fillRect(-this.width/2 - handleSize/2, -this.height/2 - handleSize/2, handleSize, handleSize);
                context.strokeRect(-this.width/2 - handleSize/2, -this.height/2 - handleSize/2, handleSize, handleSize);
                // NE (右上)
                context.fillRect(this.width/2 - handleSize/2, -this.height/2 - handleSize/2, handleSize, handleSize);
                context.strokeRect(this.width/2 - handleSize/2, -this.height/2 - handleSize/2, handleSize, handleSize);
                // SW (左下)
                context.fillRect(-this.width/2 - handleSize/2, this.height/2 - handleSize/2, handleSize, handleSize);
                context.strokeRect(-this.width/2 - handleSize/2, this.height/2 - handleSize/2, handleSize, handleSize);
                // SE (右下)
                context.fillRect(this.width/2 - handleSize/2, this.height/2 - handleSize/2, handleSize, handleSize);
                context.strokeRect(this.width/2 - handleSize/2, this.height/2 - handleSize/2, handleSize, handleSize);

                // 旋轉桿
                context.beginPath();
                context.moveTo(0, -this.height / 2);
                context.lineTo(0, -this.height / 2 - 25);
                context.stroke();
                context.beginPath();
                context.arc(0, -this.height / 2 - 25, 6, 0, Math.PI * 2);
                context.fill();
                context.stroke();
            }
            context.restore();
        }

        // 轉換全域座標到圖片局部座標 (未旋轉的矩形空間)
        toLocal(px, py) {
            const cx = this.x + this.width / 2;
            const cy = this.y + this.height / 2;
            const dx = px - cx;
            const dy = py - cy;
            const cos = Math.cos(-this.angle);
            const sin = Math.sin(-this.angle);
            // 旋轉回正
            const rx = dx * cos - dy * sin;
            const ry = dx * sin + dy * cos;
            return { x: rx, y: ry };
        }

        contains(px, py) {
            const p = this.toLocal(px, py);
            return p.x >= -this.width/2 && p.x <= this.width/2 && p.y >= -this.height/2 && p.y <= this.height/2;
        }

        // 檢查控制點
        checkControlPoints(px, py) {
            const p = this.toLocal(px, py);
            const h = 15; // 點擊感應半徑

            // 旋轉點
            if (Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y - (-this.height/2 - 25), 2)) < 15) return "rotate";

            // 四角控制點
            if (Math.abs(p.x - (-this.width/2)) < h && Math.abs(p.y - (-this.height/2)) < h) return "nw";
            if (Math.abs(p.x - (this.width/2)) < h && Math.abs(p.y - (-this.height/2)) < h) return "ne";
            if (Math.abs(p.x - (-this.width/2)) < h && Math.abs(p.y - (this.height/2)) < h) return "sw";
            if (Math.abs(p.x - (this.width/2)) < h && Math.abs(p.y - (this.height/2)) < h) return "se";
            
            return null;
        }
    }

    // --- Canvas 渲染與初始化 ---
    function setupCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = Math.max(window.innerHeight - 100, 600);
      bgCanvas.width = canvas.width;
      bgCanvas.height = canvas.height;
      [ctx, bgCtx].forEach(c => {
        c.lineCap = "round"; c.lineJoin = "round";
        c.imageSmoothingEnabled = true; c.imageSmoothingQuality = 'high';
      });
      renderAll();
    }

    function renderAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(bgCanvas, 0, 0);
        images.forEach(img => img.draw(ctx));
    }

    function showToast(msg) {
        toastMsg.textContent = msg; toastMsg.style.opacity = 1;
        setTimeout(() => { toastMsg.style.opacity = 0; }, 3000);
    }

    setupCanvas();
    saveCurrentPageData();
    window.addEventListener('resize', () => {
        const tempImg = bgCanvas.toDataURL();
        const img = new Image();
        img.onload = () => {
            setupCanvas();
            bgCtx.drawImage(img, 0, 0); renderAll();
        }
        img.src = tempImg;
    });

    // --- 筆刷繪圖核心 ---
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return { x: (e.clientX - rect.left) * (canvas.width / rect.width), y: (e.clientY - rect.top) * (canvas.height / rect.height) };
    }
    function getTouchPos(touch) {
      const rect = canvas.getBoundingClientRect();
      return { x: (touch.clientX - rect.left) * (canvas.width / rect.width), y: (touch.clientY - rect.top) * (canvas.height / rect.height) };
    }
    function distance(p1, p2) { return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)); }
    
    function drawSmoothLine(from, to, pressure = 1.0) {
      if (!from || !to) return;
      const dist = distance(from, to);
      if (dist < 0.1 || dist > 100) return;
      const brushWidth = (currentTool === "brush" ? brushSize : getCurrentEraserSize()) * pressure;
      const radius = brushWidth / 2;
      bgCtx.save();
      bgCtx.imageSmoothingEnabled = true;
      if (currentTool === "brush") { bgCtx.globalCompositeOperation = "source-over"; bgCtx.fillStyle = brushColor; } 
      else { bgCtx.globalCompositeOperation = "destination-out"; }
      const steps = Math.max(3, Math.floor(dist * 2));
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const x = from.x + (to.x - from.x) * t;
        const y = from.y + (to.y - from.y) * t;
        bgCtx.globalAlpha = 1.0; bgCtx.beginPath(); bgCtx.arc(x, y, radius, 0, Math.PI * 2); bgCtx.fill();
        for (let l = 1; l <= 3; l++) {
          bgCtx.globalAlpha = 0.3 / l; bgCtx.beginPath(); bgCtx.arc(x, y, radius + l * 0.5, 0, Math.PI * 2); bgCtx.fill();
        }
      }
      bgCtx.restore();
      renderAll();
    }
    function drawSinglePoint(pos) {
      if (!pos) return;
      bgCtx.save();
      if (currentTool === "brush") { bgCtx.globalCompositeOperation = "source-over"; bgCtx.fillStyle = brushColor; } 
      else { bgCtx.globalCompositeOperation = "destination-out"; }
      bgCtx.beginPath(); bgCtx.arc(pos.x, pos.y, (currentTool === "brush" ? brushSize : getCurrentEraserSize()) / 2, 0, Math.PI * 2); bgCtx.fill();
      bgCtx.restore();
      renderAll();
    }

    // --- 存檔/讀檔 ---
    function saveCurrentPageData() { pageData[currentPage] = { strokeData: bgCanvas.toDataURL(), images: images }; }
    function loadCurrentPageData() {
      bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height); images = [];
      if (pageData[currentPage]) {
        images = pageData[currentPage].images || [];
        const img = new Image();
        img.onload = function() { bgCtx.drawImage(img, 0, 0); renderAll(); };
        img.src = pageData[currentPage].strokeData || '';
      } else { renderAll(); }
    }

    // --- 工具邏輯 ---
    function isPalmTouch(t) { return ((t.radiusX||0) + (t.radiusY||0))/2 > 15; }
    function getCurrentEraserSize() { return isPalmMode ? palmEraserSize : eraserSize; }
    function enablePalmMode(t) { if(!isPalmMode) { originalTool = currentTool; isPalmMode = true; if(t) palmEraserSize = Math.max(80, Math.min(150, ((t.radiusX||25)+(t.radiusY||25))/2 * 3)); selectTool("eraser"); } if(palmModeTimeout) clearTimeout(palmModeTimeout); }
    function scheduleDisablePalmMode() { if(palmModeTimeout) clearTimeout(palmModeTimeout); palmModeTimeout = setTimeout(() => { if(isPalmMode) { isPalmMode = false; selectTool(originalTool); } }, 100); }

    // --- 交互事件 ---
    canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(e);
        
        if (selectedImage) {
            const action = selectedImage.checkControlPoints(pos.x, pos.y);
            if (action) {
                if (action === "rotate") { isRotatingImg = true; } 
                else { 
                    isResizingImg = true; 
                    resizeDir = action; 
                    // 記錄開始縮放時的圖片狀態
                    initialImgState = { 
                        x: selectedImage.x, 
                        y: selectedImage.y, 
                        w: selectedImage.width, 
                        h: selectedImage.height,
                        cx: selectedImage.x + selectedImage.width/2,
                        cy: selectedImage.y + selectedImage.height/2,
                        angle: selectedImage.angle
                    };
                }
                return;
            }
        }

        let hit = false;
        for (let i = images.length - 1; i >= 0; i--) {
            if (images[i].contains(pos.x, pos.y)) {
                selectedImage = images[i];
                images.splice(i, 1); images.push(selectedImage);
                isDraggingImg = true;
                dragStartX = pos.x - selectedImage.x;
                dragStartY = pos.y - selectedImage.y;
                hit = true; renderAll(); break;
            }
        }

        if (!hit) {
            selectedImage = null; renderAll();
            if (currentTool !== "none") { drawing = true; lastPoint = pos; drawSinglePoint(pos); }
        }
    });

    window.addEventListener("mousemove", (e) => {
        const pos = getMousePos(e);
        const clientPos = { x: e.clientX, y: e.clientY };

        if (isDraggingImg && selectedImage) {
            selectedImage.x = pos.x - dragStartX;
            selectedImage.y = pos.y - dragStartY;
            renderAll();
        } 
        else if (isResizingImg && selectedImage) {
            // 四角縮放數學邏輯
            // 1. 將滑鼠當前位置轉換到「未旋轉」的相對座標系中
            // 我們以圖片原本的中心點為參考
            const dx = pos.x - initialImgState.cx;
            const dy = pos.y - initialImgState.cy;
            
            // 逆旋轉矩陣，找出滑鼠相對於圖片中心(未旋轉時)的偏移
            const cos = Math.cos(-initialImgState.angle);
            const sin = Math.sin(-initialImgState.angle);
            const rx = dx * cos - dy * sin;
            const ry = dx * sin + dy * cos;

            // 原始邊界 (相對於中心)
            const oldHalfW = initialImgState.w / 2;
            const oldHalfH = initialImgState.h / 2;

            // 根據拖曳的角落，計算新的邊界 (left, top, right, bottom)
            // 這裡是相對於原始中心的 Local 座標
            let newLeft = -oldHalfW;
            let newRight = oldHalfW;
            let newTop = -oldHalfH;
            let newBottom = oldHalfH;

            // 自由縮放 (不鎖定比例)
            if (resizeDir === "nw") { newLeft = rx; newTop = ry; }
            else if (resizeDir === "ne") { newRight = rx; newTop = ry; }
            else if (resizeDir === "sw") { newLeft = rx; newBottom = ry; }
            else if (resizeDir === "se") { newRight = rx; newBottom = ry; }
            
            // 防止縮太小翻轉
            if(newRight - newLeft < 10) { if(resizeDir.includes('w')) newLeft = newRight - 10; else newRight = newLeft + 10; }
            if(newBottom - newTop < 10) { if(resizeDir.includes('n')) newTop = newBottom - 10; else newBottom = newTop + 10; }

            // 計算新的寬高
            const newW = newRight - newLeft;
            const newH = newBottom - newTop;

            // 計算新的中心點偏移 (在 Local 座標系中)
            const newCenterOffX = (newLeft + newRight) / 2;
            const newCenterOffY = (newTop + newBottom) / 2;

            // 將新的中心點偏移轉回 Global 座標系 (順旋轉)
            const rotCos = Math.cos(initialImgState.angle);
            const rotSin = Math.sin(initialImgState.angle);
            const globalOffX = newCenterOffX * rotCos - newCenterOffY * rotSin;
            const globalOffY = newCenterOffX * rotSin + newCenterOffY * rotCos;

            // 更新圖片屬性
            selectedImage.width = newW;
            selectedImage.height = newH;
            // 新的 Global 中心位置 = 舊中心 + 旋轉後的偏移
            const newCx = initialImgState.cx + globalOffX;
            const newCy = initialImgState.cy + globalOffY;
            
            // 最後轉回左上角座標
            selectedImage.x = newCx - newW / 2;
            selectedImage.y = newCy - newH / 2;

            renderAll();
        }
        else if (isRotatingImg && selectedImage) {
            const centerX = selectedImage.x + selectedImage.width / 2;
            const centerY = selectedImage.y + selectedImage.height / 2;
            selectedImage.angle = Math.atan2(pos.y - centerY, pos.x - centerX) + Math.PI / 2;
            renderAll();
        }
        else if (drawing && currentTool !== "none") {
            if (lastPoint && distance(lastPoint, pos) <= 100) drawSmoothLine(lastPoint, pos);
            lastPoint = pos;
        }

        updateEraserCursorPosition(clientPos.x, clientPos.y);
    });

    window.addEventListener("mouseup", () => {
        drawing = false; lastPoint = null;
        isDraggingImg = false; isResizingImg = false; isRotatingImg = false;
    });

    // 觸控支援 (簡化版：只支援單指操作)
    canvas.addEventListener("touchstart", (e) => {
        e.preventDefault(); const t = e.touches[0]; const pos = getTouchPos(t);
        // 手掌偵測
        for(let i=0; i<e.touches.length; i++) if(isPalmTouch(e.touches[i])) enablePalmMode(e.touches[i]);
        if(!isPalmMode) {
             // 優先檢查選取圖片
            let hit = false;
             // 檢查控制點 (僅簡單支援，手指較難精確點擊)
            if (selectedImage) {
                const action = selectedImage.checkControlPoints(pos.x, pos.y);
                if(action) {
                     if(action === "rotate") isRotatingImg = true;
                     else {
                         isResizingImg = true; resizeDir = action;
                         initialImgState = { x: selectedImage.x, y: selectedImage.y, w: selectedImage.width, h: selectedImage.height, cx: selectedImage.x+selectedImage.width/2, cy: selectedImage.y+selectedImage.height/2, angle: selectedImage.angle };
                     }
                     return;
                }
            }

            for(let i=images.length-1; i>=0; i--) {
                if(images[i].contains(pos.x, pos.y)) {
                    selectedImage = images[i]; images.splice(i, 1); images.push(selectedImage);
                    isDraggingImg = true; dragStartX = pos.x - selectedImage.x; dragStartY = pos.y - selectedImage.y;
                    hit = true; renderAll(); break;
                }
            }
            if(!hit) {
                selectedImage = null; renderAll();
                if(currentTool !== "none") { drawing = true; lastPoint = pos; drawSinglePoint(pos); }
            }
        }
    }, {passive:false});

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault(); const t = e.touches[0]; const pos = getTouchPos(t);
        // 復用滑鼠移動邏輯
        if (isDraggingImg && selectedImage) {
            selectedImage.x = pos.x - dragStartX; selectedImage.y = pos.y - dragStartY; renderAll();
        } else if (isResizingImg && selectedImage) {
             // 複製上面的數學邏輯
            const dx = pos.x - initialImgState.cx; const dy = pos.y - initialImgState.cy;
            const cos = Math.cos(-initialImgState.angle); const sin = Math.sin(-initialImgState.angle);
            const rx = dx * cos - dy * sin; const ry = dx * sin + dy * cos;
            const oldHalfW = initialImgState.w / 2; const oldHalfH = initialImgState.h / 2;
            let newLeft = -oldHalfW, newRight = oldHalfW, newTop = -oldHalfH, newBottom = oldHalfH;

            if (resizeDir === "nw") { newLeft = rx; newTop = ry; }
            else if (resizeDir === "ne") { newRight = rx; newTop = ry; }
            else if (resizeDir === "sw") { newLeft = rx; newBottom = ry; }
            else if (resizeDir === "se") { newRight = rx; newBottom = ry; }

            if(newRight - newLeft < 10) { if(resizeDir.includes('w')) newLeft = newRight - 10; else newRight = newLeft + 10; }
            if(newBottom - newTop < 10) { if(resizeDir.includes('n')) newTop = newBottom - 10; else newBottom = newTop + 10; }

            const newW = newRight - newLeft; const newH = newBottom - newTop;
            const newCenterOffX = (newLeft + newRight) / 2; const newCenterOffY = (newTop + newBottom) / 2;
            const rotCos = Math.cos(initialImgState.angle); const rotSin = Math.sin(initialImgState.angle);
            const globalOffX = newCenterOffX * rotCos - newCenterOffY * rotSin;
            const globalOffY = newCenterOffX * rotSin + newCenterOffY * rotCos;

            selectedImage.width = newW; selectedImage.height = newH;
            selectedImage.x = (initialImgState.cx + globalOffX) - newW / 2;
            selectedImage.y = (initialImgState.cy + globalOffY) - newH / 2;
            renderAll();
        } else if (isRotatingImg && selectedImage) {
             const centerX = selectedImage.x + selectedImage.width/2; const centerY = selectedImage.y + selectedImage.height/2;
             selectedImage.angle = Math.atan2(pos.y-centerY, pos.x-centerX) + Math.PI/2; renderAll();
        } else if (drawing && !isPalmMode) {
            if(lastPoint && distance(lastPoint, pos) <= 100) drawSmoothLine(lastPoint, pos); lastPoint = pos;
        }
        if(e.touches.length > 0) updateEraserCursorPosition(t.clientX, t.clientY);
    }, {passive:false});

    canvas.addEventListener("touchend", (e) => {
        e.preventDefault(); drawing = false; lastPoint = null; isDraggingImg = false; isResizingImg = false; isRotatingImg = false;
        if(e.touches.length === 0) scheduleDisablePalmMode();
    }, {passive:false});

    // --- 貼上功能 ---
    window.addEventListener("paste", (e) => {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf("image") !== -1) {
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const img = new Image();
                    img.onload = () => {
                        const newImg = new WhiteboardImage(img, canvas.width/2 - 100, canvas.height/2 - 100);
                        images.push(newImg); selectedImage = newImg; renderAll(); showToast("圖片已貼上");
                    };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(blob);
            }
        }
    });

    // --- UI 綁定 ---
    function selectTool(tool) {
      document.querySelectorAll('#sidebar button').forEach(b => b.classList.remove('active'));
      currentTool = tool; updateSizePreview();
      if (tool === "brush") { brushBtn.classList.add('active'); canvas.style.cursor = "crosshair"; eraserCursor.style.display = "none"; }
      else if (tool === "eraser") { eraserBtn.classList.add('active'); canvas.style.cursor = "none"; eraserCursor.style.display = "block"; updateEraserCursor(); }
      else { canvas.style.cursor = "default"; eraserCursor.style.display = "none"; }
    }
    function updateEraserCursor() { if(currentTool==="eraser") { const s=getCurrentEraserSize(); eraserCursor.style.width=s+'px'; eraserCursor.style.height=s+'px'; } }
    function updateEraserCursorPosition(x, y) { if(currentTool==="eraser") { eraserCursor.style.left=x+'px'; eraserCursor.style.top=y+'px'; } }
    function updateSizePreview() {
      brushSizeDisplay.innerText = brushSize; brushSizeCircle.style.width = Math.min(brushSize,30)+'px'; brushSizeCircle.style.height = Math.min(brushSize,30)+'px'; brushSizeCircle.style.backgroundColor=brushColor;
      eraserSizeDisplay.innerText = eraserSize; eraserSizeCircle.style.width = Math.min(eraserSize/2,30)+'px'; eraserSizeCircle.style.height = Math.min(eraserSize/2,30)+'px';
    }

    brushBtn.onclick = () => { if(currentTool!=="brush"){selectTool("brush");brushSettings.classList.add("hidden")} else {brushSettings.classList.toggle("hidden");if(!brushSettings.classList.contains("hidden")) {brushSection.style.display="block";eraserSection.style.display="none";}} };
    eraserBtn.onclick = () => { if(currentTool!=="eraser"){selectTool("eraser");brushSettings.classList.add("hidden")} else {brushSettings.classList.toggle("hidden");if(!brushSettings.classList.contains("hidden")) {brushSection.style.display="none";eraserSection.style.display="block";}} };
    clearBtn.onclick = () => { bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height); images=[]; pageData[currentPage]={strokeData:null,images:[]}; renderAll(); };
    brushColorInput.oninput = (e) => { brushColor = e.target.value; updateSizePreview(); };
    brushSizeInput.oninput = (e) => { brushSize = parseInt(e.target.value); updateSizePreview(); };
    eraserSizeInput.oninput = (e) => { eraserSize = parseInt(e.target.value); updateSizePreview(); updateEraserCursor(); };
    
    // 側欄切換
    let sidebarOnLeft = true;
    document.body.onclick = (e) => {
        if(e.target===canvas){brushSettings.classList.add("hidden"); return;}
        if(!sidebar.contains(e.target) && !brushSettings.contains(e.target) && !pageControls.contains(e.target)) {
            const isLeft = e.clientX < window.innerWidth/2;
            if(isLeft === sidebarOnLeft) sidebar.classList.toggle("hidden");
            else { sidebarOnLeft = isLeft; sidebar.style.left=isLeft?"4%":"auto"; sidebar.style.right=isLeft?"auto":"4%"; brushSettings.style.left=isLeft?"12%":"auto"; brushSettings.style.right=isLeft?"auto":"12%"; sidebar.classList.remove("hidden"); }
        }
    };

    updateSizePreview(); selectTool("brush");
  </script>
</body>
</html>